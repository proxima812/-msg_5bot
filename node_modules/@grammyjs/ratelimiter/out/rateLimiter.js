"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.limit = void 0;
const memoryStore_js_1 = require("./memoryStore.js");
const typesAndDefaults_js_1 = require("./typesAndDefaults.js");
const redisStore_js_1 = require("./redisStore.js");
/**
 *
 * @param UserOptions an object of rateLimiter options:
 * ```ts
 * {
 *   timeFrame: 1000,
 *   limit: 1,
 *   onLimitExceeded: (ctx, next) => {},
 *   storageClient: "MEMORY_STORE",
 *   keyGenerator: (ctx) => ctx.from && ctx.from.id.toString(),
 * }
 * ```
 *
 * as explained in [customizability](https://github.com/Amir-Zouerami/rateLimiter#-customizability)
 * @description A middleware function generator
 * @returns a middleware function to be passed to `bot.use()`
 */
const limit = (userOptions) => {
    var _a;
    const options = { ...typesAndDefaults_js_1.defaultOptions, ...userOptions };
    const store = options.storageClient === "MEMORY_STORE"
        ? new memoryStore_js_1.MemoryStore(options.timeFrame)
        : new redisStore_js_1.RedisStore(options.storageClient, options.timeFrame);
    const keyPrefix = (_a = userOptions === null || userOptions === void 0 ? void 0 : userOptions.keyPrefix) !== null && _a !== void 0 ? _a : typesAndDefaults_js_1.defaultOptions.keyPrefix;
    const middlewareFunc = async (ctx, next) => {
        const key = options.keyGenerator(ctx);
        if (!key) {
            return await next();
        }
        const hits = await store.increment(keyPrefix + key);
        if (hits === options.limit + 1 || (options.alwaysReply && hits > options.limit)) {
            return options.onLimitExceeded(ctx, next);
        }
        if (hits <= options.limit) {
            return await next();
        }
    };
    return middlewareFunc;
};
exports.limit = limit;
